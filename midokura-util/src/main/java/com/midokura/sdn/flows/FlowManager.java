/*
 * Copyright 2012 Midokura Europe SARL
 */

package com.midokura.sdn.flows;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.midokura.sdn.dp.Flow;
import com.midokura.sdn.dp.FlowMatch;
import com.midokura.sdn.dp.flows.FlowAction;

// not thread-safe
// TODO(pino): document this
// TODO(pino): implement eviction of wildcard flows
// TODO(pino): implement flow removal notification. Keep in mind that during
// TODO:       simulation, the match for the installed flow is not yet known.
public class FlowManager {

    /* Each wildcard flow table is a map of wildcard match to wildcard flow.
     * The FlowManager needs one wildcard flow table for every wildcard pattern,
     * where a pattern is a set of fields used by the match.
     * The wildcardTables structure maps wildcard pattern to wildcard flow
     * table.
     */
    private Map<Set<WildcardMatch.Field>, Map<WildcardMatch, WildcardFlow>>
            wildcardTables =
            new HashMap<Set<WildcardMatch.Field>,
                    Map<WildcardMatch, WildcardFlow>>();

    /* The datapath flow table is a map of datapath FlowMatch to a list of
     * FlowActions. The datapath flow table is a LinkedHashMap so that we
     * can iterate it in insertion-order (e.g. to find flows that are
     * candidates for eviction).
     */
    private LinkedHashMap<FlowMatch, List<FlowAction<?>>> dpFlowTable =
            new LinkedHashMap<FlowMatch, List<FlowAction<?>>>();

    /* Map each datapath flow back to its wildcard flow */
    private Map<FlowMatch, WildcardFlow> dpFlowToWildFlow =
            new HashMap<FlowMatch, WildcardFlow>();
    /* Map each wildcard flow to the set of datapath flows it generated. */
    private Map<WildcardFlow, Set<FlowMatch>> wildFlowToDpFlows =
            new HashMap<WildcardFlow, Set<FlowMatch>>();

    public int getNumDpFlows() {
        return dpFlowTable.size();
    }

    public List<FlowMatch> removeOldestDpFlows(int numToRemove) {
        if (numToRemove <= 0)
            throw new IllegalArgumentException("numToRemove must be positive");
        List<FlowMatch> removed = new ArrayList<FlowMatch>(numToRemove);
        Iterator<FlowMatch> it = dpFlowTable.keySet().iterator();
        while (removed.size() < numToRemove && it.hasNext()) {
            removed.add(it.next());
            it.remove();
        }
        return removed;
    }

    /**
     * Add a new wildcard flow.
     *
     * @param wildFlow
     * @return True iff the wildcard flow was added. The flow will not be
     *         added if the table already contains a wildcard flow with the same
     *         match.
     */
    public boolean add(WildcardFlow wildFlow) {
        // Get the WildcardFlowTable for this wild flow's pattern.
        Set<WildcardMatch.Field> pattern =
                wildFlow.getMatch().getUsedFields();
        Map<WildcardMatch, WildcardFlow> wildTable = wildcardTables.get(pattern);
        if (null == wildTable) {
            wildTable = new HashMap<WildcardMatch, WildcardFlow>();
            wildcardTables.put(pattern, wildTable);
        }
        if (!wildTable.containsKey(wildFlow.match)) {
            wildTable.put(wildFlow.match, wildFlow);
            wildFlowToDpFlows.put(wildFlow, new HashSet<FlowMatch>());
            return true;
        }
        return false;
    }

    /**
     * Add a new datapath flow and associate it to an existing wildcard flow
     * and its actions. The wildcard flow must have previously been successfully
     * added or the behavior is undefined.
     *
     * @param wildFlow
     * @param flowMatch
     * @return True iff both the datapath flow was added. The flow will not be
     *         added if the table already contains a datapath flow with the same
     *         match.
     */
    public boolean add(FlowMatch flowMatch, WildcardFlow wildFlow) {
        if (dpFlowTable.containsKey(flowMatch))
            return false;
        dpFlowTable.put(flowMatch, wildFlow.actions);
        dpFlowToWildFlow.put(flowMatch, wildFlow);
        wildFlowToDpFlows.get(wildFlow).add(flowMatch);
        return true;
    }

    /**
     * Remove a wildcard flow and its associated datapath flows.  The wildcard
     * flow must have previously been successfully added or the behavior is
     * undefined.
     *
     * @param wildFlow
     * @return the set of datapath flows that was generated by this wild flow.
     */
    public Set<FlowMatch> remove(WildcardFlow wildFlow) {
        Set<FlowMatch> removedDpFlows = wildFlowToDpFlows.remove(wildFlow);
        for (FlowMatch flowMatch : removedDpFlows) {
            dpFlowToWildFlow.remove(flowMatch);
            dpFlowTable.remove(flowMatch);
        }
        // Get the WildcardFlowTable for this wild flow's pattern and remove
        // the wild flow.
        wildcardTables.get(wildFlow.getMatch().getUsedFields())
                .remove(wildFlow.match);
        return removedDpFlows;
    }

    /**
     * If a datapath flow matching this FlowMatch was already computed, return
     * its actions. Else null.
     *
     * @param flowMatch
     * @return
     */
    public List<FlowAction<?>> getActionsForDpFlow(FlowMatch flowMatch) {
        return dpFlowTable.get(flowMatch);
    }

    /**
     * If the datapath FlowMatch matches a wildcard flow, create the datapath
     * Flow. If the FlowMatch matches multiple wildcard flows, the FlowManager
     * will arbitrarily choose one that has the highest priority (lowest
     * priority value). If the FlowManager already contains a datapath flow
     * for this FlowMatch, it will return a copy of that instead.
     *
     * @param flowMatch
     * @return A datapath Flow if one already exists or a new one if the
     *         FlowMatch matches a wildcard flow. Otherwise, null.
     */
    public Flow createDpFlow(FlowMatch flowMatch) {
        List<FlowAction<?>> actions = dpFlowTable.get(flowMatch);
        if (null != actions)
            return new Flow().setMatch(flowMatch).setActions(actions);
        // Iterate through the WildcardFlowTables to find candidate wild flows.
        WildcardFlow wFlowCandidate = null;
        WildcardMatch flowWildMatch = WildcardMatches.fromFlowMatch(flowMatch);
        for (Map.Entry<Set<WildcardMatch.Field>,
                Map<WildcardMatch, WildcardFlow>> wTableEntry :
                wildcardTables.entrySet()) {
            Map<WildcardMatch, WildcardFlow> table = wTableEntry.getValue();
            Set<WildcardMatch.Field> pattern = wTableEntry.getKey();
            ProjectedWildcardMatch projectedFlowMatch = WildcardMatches.project(
                    pattern, flowWildMatch);
            WildcardFlow nextWFlowCandidate = table.get(projectedFlowMatch);
            if (null != nextWFlowCandidate) {
                if (null == wFlowCandidate)
                    wFlowCandidate = nextWFlowCandidate;
                else if (nextWFlowCandidate.priority < wFlowCandidate.priority)
                    wFlowCandidate = nextWFlowCandidate;
            }
        }
        // If we found a valid wildcard flow, create a Flow for the FlowMatch.
        if (null == wFlowCandidate)
            return null;
        else {
            Flow dpFlow = new Flow().setMatch(flowMatch)
                    .setActions(wFlowCandidate.getActions());
            assert(add(flowMatch, wFlowCandidate));
            return dpFlow;
        }
    }

}
