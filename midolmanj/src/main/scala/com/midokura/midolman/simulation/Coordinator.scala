// Copyright 2012 Midokura Inc.

package com.midokura.midolman.simulation

import collection.mutable
import util.continuations.cps

import akka.dispatch.{Future, ExecutionContext}
import akka.dispatch.Future._
import akka.pattern.ask
import akka.util.Timeout
import akka.util.duration._

import com.google.inject.Inject

import java.util.UUID

import com.midokura.midolman.topology._
import com.midokura.packets.Ethernet
import com.midokura.sdn.flows.WildcardMatch
import com.midokura.util.functors.Callback0
import com.midokura.midolman.FlowController.{AddWildcardFlow, Drop, SendPacket}
import com.midokura.midolman.{FlowController, DatapathController}
import com.midokura.midolman.services.MidolmanActorsService
import com.midokura.sdn.dp.{FlowMatch, Packet}
import com.midokura.midolman.datapath.FlowActionVrnPortOutput

object Coordinator {
    trait Action

    case class DropAction() extends Action
    // NotIPv4Action implies a DROP flow. However, it differs from DropAction
    // in that the installed flow match can have all fields >L2 wildcarded.
    // TODO(pino): make the installed flow computation smarter so that it
    // TODO:       wildcards any field that wasn't used by the simulation. Then
    // TODO:       remove NotIPv4Action
    case class NotIPv4Action() extends Action
    case class ConsumedAction() extends Action
    case class ForwardAction(outPort: UUID) extends Action

    trait PacketContext {
        // This set will store the callback to call when this flow is removed
        val flowRemovedCallbacks = mutable.Set[Callback0]()
        def addFlowRemovedCallback(cb: Callback0) {
            flowRemovedCallbacks.add(cb)
        }
        // This Set will store the tags by which the flow should be indexed
        // The index can be used to remove flows associated with the given tag
        val flowTags = mutable.Set[Any]()
        def addFlowTag(tag: Any) {
            flowTags.add(tag)
        }
    }

    trait Device {
        /**
         * Process a packet described by the given match object. Note that the
         * Ethernet packet is the one originally ingressed the virtual network
         * - it does not reflect the changes made by other devices' handling of
         * the packet (whereas the match object does).
         *
         * @param pktMatch The wildcard match that describes the packet's
         * fields at the time it ingresses the device. This match contains the
         * UUID of the ingress port; it can be accessed via getInputPortUUID.
         * The implementation of process should modify the pktMatch to reflect
         * how the device would modify the packet during handling/forwarding.
         * @param packet The original packet that ingressed the virtual network,
         * which may be different from the packet that actually arrives at this
         * device.
         * @param pktContext The context for the simulation of this packet's
         * traversal of the virtual network. Use the context to subscribe
         * for notifications on the removal of any resulting flows, or to tag
         * any resulting flows for indexing.
         * @param ec the Coordinator actor's execution context.
         * @return An instance of Action that reflects what the device would do
         * after handling this packet (e.g. drop it, consume it, forward it).
         */
        def process(pktMatch: WildcardMatch,
                    packet: Ethernet,
                    pktContext: PacketContext)
                    (implicit ec: ExecutionContext): Action @cps[Future[_]]
    }
}

class Coordinator {
    import Coordinator._

    @Inject
    var actors: MidolmanActorsService

    /**
     * Simulate a single packet moving through the virtual topology. A packet
     * begins its journey through the virtual topology in one of these ways:
     * 1) it ingresses an exterior port of a virtual device (in which case the
     * packet arrives via the datapath switch from an entity outside the
     * virtual topology).
     * 2) it egresses an interior port of a virtual device (in which case the
     * packet was generated by that virtual device).
     *
     * In case 1, the match object for the packet was computed by the
     * FlowController and must contain an inPortID. If a wildcard flow is
     * eventually installed in the FlowController, the match will be a subset
     * of the match originally provided to the simulation. Note that in this
     * case the generatedPacketEgressPort argument should be null and will be
     * ignored.
     *
     * In case 2, the match object for the packet was computed by the Device
     * that emitted the packet and must not contain an inPortID. If the packet
     * is not dropped, it will eventually result in a packet being emitted
     * from one or more of the datapath ports. However, a flow is never
     * installed as a result of such a simulation. Note that in this case the
     * generatedPacketEgressPort argument must not be null.
     *
     * When this method completes, it may send a message to the Datapath
     * Controller to install a flow or send a packet.
     *
     * @param origMatch
     * @param packet
     * @param generatedPacketEgressPort Only used if this packet was generated
     *                                  by a virtual device. It's the ID of
     *                                  the port via which the packet
     *                                  egresses the device.
     */
    def simulate(origMatch: WildcardMatch,
                 origFlowMatch: FlowMatch,
                 packet: Array[Byte],
                 generatedPacketEgressPort: UUID)
                (implicit ec: ExecutionContext): Unit = {
        val datapathController =
            actors.system.actorFor("/user/%s" format DatapathController.Name)

        val flowController =
            actors.system.actorFor("/user/%s" format FlowController.Name)

        val virtualTopologyManager =
            actors.system.actorFor("/user/%s" format VirtualTopologyActor.Name)

        // TODO(pino): if any topology object cannot be found, log an error.
        flow {
            val origEthernetPkt = Ethernet.deserialize(packet)
            var origIngressPort: Port[_] = null
            var currentIngressPort: Port[_] = null
            var origEgressPort: Port[_] = null
            if (generatedPacketEgressPort == null) {
                if (origMatch.getInputPortUUID == null) {
                    throw new IllegalArgumentException(
                        "Coordinator cannot simulate a flow that NEITHER " +
                        "egressed a virtual device's interior port NOR " +
                        "ingressed a virtual device's exterior port. Match: " +
                        "%s; Packet: %s".format(
                            origMatch.toString, origEthernetPkt.toString))
                } else {
                    origIngressPort = virtualTopologyManager.ask(
                        PortRequest(origMatch.getInputPortUUID, false)
                    )(Timeout(1 second)).mapTo[Port[_]].apply()
                    currentIngressPort = origIngressPort
                }
            } else { // it IS a generated packet
                if (origMatch.getInputPortUUID != null) {
                    throw new IllegalArgumentException(
                        "Coordinator cannot simulate a flow that BOTH " +
                        "egressed a virtual device's interior port AND " +
                        "ingressed a virtual device's exterior port. Match: " +
                        "%s; Packet: %s".format(
                            origMatch.toString, origEthernetPkt.toString))
                } else {
                    origEgressPort = virtualTopologyManager.ask(
                        PortRequest(generatedPacketEgressPort, false)
                    )(Timeout(1 second)).mapTo[Port[_]].apply()
                    // TODO(pino): apply the port's output filter
                    if (origEgressPort.isInstanceOf[ExteriorPort[_]]) {
                        val pkt = new Packet().
                            setData(packet).
                            addAction(new FlowActionVrnPortOutput(
                                generatedPacketEgressPort))
                        // TODO(pino): replace null with actions?
                        datapathController.tell(SendPacket(pkt.getData, null))
                    } else {
                        val peerID =
                            origEgressPort.asInstanceOf[InteriorPort[_]].peerID
                        currentIngressPort = virtualTopologyManager.ask(
                            PortRequest(peerID, false)
                        )(Timeout(1 second)).mapTo[Port[_]].apply()
                    }
                }
            }
            val isInternallyGenerated = generatedPacketEgressPort != null

            // Used to detect loops.
            val traversedFEs = mutable.Map[UUID, Int]()
            // depth of devices traversed in the simulation
            val depth: Int = 0

            // Used for connection tracking
            val connectionTracked = false
            val forwardFlow = false
            // TODO(pino): val connectionCache
            // Connection-tracking is not done for internally generated packets.
            val ingressDeviceID: UUID = if (isInternallyGenerated)
                null else origIngressPort.deviceID

            val pktContext = new PacketContext {}

            while (true) {
                // TODO(pino): check for too long loop
                // TODO(pino): the port's input filter.
                var currentDevice: Device = null
                if (currentIngressPort.isInstanceOf[BridgePort[_]])
                    currentDevice = virtualTopologyManager.ask(
                        BridgeRequest(currentIngressPort.deviceID, false)
                    )(Timeout(1 second)).mapTo[Bridge].apply()
                else if (currentIngressPort.isInstanceOf[RouterPort[_]])
                    currentDevice = virtualTopologyManager.ask(
                        RouterRequest(currentIngressPort.deviceID, false)
                    )(Timeout(1 second)).mapTo[Router].apply()
                else throw new RuntimeException("fooey")
                val action = currentDevice.process(
                    origMatch.clone(), origEthernetPkt, pktContext)
                action match {
                    case ConsumedAction =>
                        if (!isInternallyGenerated)
                            flowController.tell(Drop(origFlowMatch))
                        return
                    case DropAction =>
                        if (!isInternallyGenerated)
                            datapathController.tell(AddWildcardFlow(
                                origMatch,
                                origFlowMatch,
                                pktContext.flowRemovedCallbacks,
                                pktContext.flowTags
                            ))
                        return
                    case NotIPv4Action =>
                        if (!isInternallyGenerated) {
                            val notIPv4Match = new WildcardMatch().
                                setInputPortUUID(origMatch.getInputPortUUID).
                                setEthernetSource(origMatch.getEthernetSource).
                                setEthernetDestination(
                                    origMatch.getEthernetDestination).
                                setEtherType(origMatch.getEtherType)
                            datapathController.tell(AddWildcardFlow(
                                notIPv4Match,
                                origFlowMatch,
                                pktContext.flowRemovedCallbacks,
                                pktContext.flowTags))
                        }
                        return
                    case ForwardAction(outPortID) =>
                        val outPort = virtualTopologyManager.ask(
                            PortRequest(outPortID, false)
                        )(Timeout(1 second)).mapTo[Port[_]].apply()
                        // TODO(pino): apply the port's output filter
                        if (outPort.isInstanceOf[ExteriorPort[_]]) {
                            // TODO(pino): Compute actions from matches' diff.
                            val pkt = new Packet()
                                .setData(packet)
                                .addAction(new FlowActionVrnPortOutput(
                                generatedPacketEgressPort))
                            if (isInternallyGenerated)
                                datapathController.tell(SendPacket(pkt))
                            else {
                                datapathController.tell(
                                    AddWildcardFlow(
                                        notIPv4Match,
                                        origFlowMatch,
                                        pktContext.flowRemovedCallbacks,
                                        pktContext.flowTags))
                            }
                            return
                        } else {
                            val peerID =
                                outPort.asInstanceOf[InteriorPort].peerID
                            currentIngressPort = virtualTopologyManager.ask(
                                PortRequest(peerID, false)
                            )(Timeout(1 second)).mapTo[Port[_]].apply()
                        }
                } // end 'action match'
            } // end while loop
        }(ec) // end flow block
    } // end simulate method
} // end Coordinator class
