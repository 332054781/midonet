// Copyright 2012 Midokura Inc.

package com.midokura.midolman.simulation

import akka.actor.{Actor, ActorRef}
import akka.event.Logging
import collection.mutable

import java.util.UUID

import com.midokura.midolman.DatapathController
import com.midokura.midolman.topology.{Port, PortRequest, VirtualTopologyActor}
import com.midokura.packets.Ethernet
import com.midokura.sdn.flows.{WildcardFlow, WildcardMatch}
import com.midokura.util.functors.Callback0
import com.midokura.sdn.dp.flows.FlowAction
import com.midokura.midolman.FlowController.{AddWildcardFlow, Consume,
                                             SendPacket}


object Coordinator {
    trait Action
    // TODO(jlm): Should we have DropResult include how wide a drop rule to use?
    //            Then we could fold in NotIPv4Result
    // (pino): I wouldn't. The device may not know all the fields that mattered,
    //         and I would like to make that mechanism more generic.
    case class DropResult() extends Action
    case class NotIPv4Result() extends Action
    case class ConsumedResult() extends Action
    case class ForwardResult(outPort: UUID, outMatch: WildcardMatch) extends Action
}

/**
 * A Coordinator is an actor that handles the simulation of a single packet
 * moving through the virtual topology (and then dies). A packet begins its
 * journey through the virtual topology in one of these ways:
 * 1) it ingresses an exterior port of a virtual device (in which case the
 * packet arrives via the datapath switch from an entity outside the virtual
 * topology).
 * 2) it egresses an interior port of a virtual device (in which case the
 * packet was generated by that virtual device).
 *
 * In case 1, the match object for the packet was computed by the FlowController
 * and must contain an inPortID. If a wildcard flow is eventually installed in
 * the FlowController, the match will be a subset of the match provided to the
 * simulation Coordinator. Note that in this case the generatedPacketEgressPort
 * argument of the constructor should be null and will be ignored.
 *
 * In case 2, the match object for the packet was computed by the Device that
 * emitted the packet and must not contain an inPortID. If the packet is not
 * dropped, it will eventually result in a packet being emitted from one or
 * more of the datapath ports. However, a flow is never installed as a result
 * of such a simulation. Note that in this case the generatedPacketEgressPort
 * argument of the constructor must not be null.
 *
 * After computing the results of a simulation, the Coordinator always
 * sends messages to the DatapathController to install a flow or send a packet.
 *
 * @param origMatch
 * @param packet
 * @param generatedPacketEgressPort Only used if this packet was generated by
 *                                  a virtual device. It's the ID of the port
 *                                  via which the packet egresses the device.
 */
class Coordinator(val origMatch: WildcardMatch, val packet: Array[Byte],
                  val generatedPacketEgressPort: UUID) extends Actor {
    import Coordinator._
    private val log = Logging(context.system, this)
    private val origEthernetPkt = Ethernet.deserialize(packet)
    private var origIngressPort: Port = null
    private var origEgressPort: Port = null
    if (generatedPacketEgressPort == null) {
        if (origMatch.getInputPortUUID == null) {
        log.error("Coordinator cannot simulate a flow that neither " +
            "egressed a virtual device's interior port nor ingressed a " +
            "virtual device's exterior port. Match: {}; Packet: {}",
            origMatch, origEthernetPkt)
        // XXX TODO(pino): kill this actor.
        } else {
            //origIngressPort = virtualTopologyManager().ask(
            //    PortRequest(origMatch.getInputPortUUID, false /* no update */))
        }
    } else {
        if (origMatch.getInputPortUUID != null) {
            log.error("Coordinator cannot simulate a flow that both " +
                "egressed a virtual device's interior port and ingressed a " +
                "virtual device's exterior port. Match: {}; Packet: {}",
                origMatch, origEthernetPkt)
            // XXX TODO(pino): kill this actor.
        } else {
            //origEgressPort = virtualTopologyManager().ask(
            //    PortRequest(origMatch.getInputPortUUID, false /* no update */))
        }
    }
    // This set will store the callback to call when this flow is removed
    private val flowRemovedCallbacks = mutable.Set[Callback0]()
    def addFlowRemovedCallback(cb: Callback0) {
        flowRemovedCallbacks.add(cb)
    }
    // This Set will store the tags by which the flow should be indexed
    // The index can be used to remove flows associated with the given tag
    private val flowTags = mutable.Set[Any]()
    def addFlowTag(tag: Any) {
        flowTags.add(tag)
    }

    def isInternallyGenerated: Boolean = { generatedPacketEgressPort != null }

    // Used by the VRNCoordinator to detect loops.
    private val traversedFEs = mutable.Map[UUID, Int]()
    // depth in the VRN simulation
    private val depth: Int = 0

    // Used for connection tracking
    private val connectionTracked = false
    private val forwardFlow = false
    // private val connectionCache
    // Connection-tracking is not done for internally generated packets.
    private val ingressDeviceID: UUID =
        if (isInternallyGenerated) null else origIngressPort.cfg.device_id

    // This starts the simulation of this Coordinator was created to handle.
    simulate(origMatch, packet)

    protected def receive = null

    def datapathController(): ActorRef = {
        // XXX TODO(pino): actorFor("/user/%s" format DatapathController.Name)
        return null
    }

    def virtualTopologyManager(): ActorRef = {
        // XXX TODO(pino): actorFor("/user/%s" format VirtualTopologyActor.Name)
        return null
    }

    def simulate(wFlowMatch: WildcardMatch, packet: Array[Byte]): Unit = {
        while (true) {
            // TODO(jlm): Check for too long loop
            val currentFE = deviceOfPort(wFlowMatch.getInputPortUUID)
            //val result = currentFE.process(pktContext, context.dispatcher)
            /* XXX TODO(pino): result match {
                case ForwardResult(outPortID, outMatch) =>
                    pktContext.mmatch = nextPortMatch.mmatch
                    val peerPort = peerOfPort(nextPortMatch.port)
                    if (peerPort == null)
                        return result
                    pktContext.port = peerPort
                case _ =>
                    // XXX TODO(pino)
            }*/
        }

        val finalMatch = null // TODO(pino)
        if (/*XXX TODO(pino): not*/ isInternallyGenerated) {
            if (true /*null != finalMatch*/) {
                // TODO(pino, jlm): diff matches to build action list
                // XXX
                val actions: List[FlowAction[_]] = null
                // XXX TODO(pino): datapathController() ! SendPacket(packet.getData, actions)
            }
            // Else, do nothing, the packet is dropped.
        } else if (true /*finalMatch == null*/) {
            // XXX TODO(pino): fController ! Consume(null)
        } else {
            // TODO(pino, jlm): compute the WildcardFlow, including actions
            // XXX
            val wildcardFlow: WildcardFlow = null
            datapathController ! AddWildcardFlow(wildcardFlow, null, null, null)
        }

    }

    private def deviceOfPort(port: UUID): Device = {
        null //XXX
    }

    private def peerOfPort(port: UUID): UUID = {
        null //XXX
    }

}
