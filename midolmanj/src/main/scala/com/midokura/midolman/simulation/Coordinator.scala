// Copyright 2012 Midokura Inc.

package com.midokura.midolman.simulation

import akka.actor.{Actor, ActorRef}
import akka.dispatch.{ExecutionContext, Future}
import akka.event.Logging
import collection.mutable
import util.continuations.cps

import java.util.UUID

import com.midokura.midolman.DatapathController
import com.midokura.midolman.topology.{Port, PortRequest, VirtualTopologyActor}
import com.midokura.packets.Ethernet
import com.midokura.sdn.flows.{WildcardFlow, WildcardMatch}
import com.midokura.util.functors.Callback0
import com.midokura.sdn.dp.flows.FlowAction
import com.midokura.midolman.FlowController.{AddWildcardFlow, Consume,
                                             SendPacket}


object Coordinator {
    trait Action

    case class DropAction() extends Action
    // NotIPv4Action implies a DROP flow. However, it differs from DropAction
    // in that the installed flow match can have all fields >L2 wildcarded.
    // TODO(pino): make the installed flow computation smarter so that it
    // TODO:       wildcards any field that wasn't used by the simulation. Then
    // TODO:       remove NotIPv4Action
    case class NotIPv4Action() extends Action
    case class ConsumedAction() extends Action
    case class ForwardAction(outPort: UUID) extends Action

    trait PacketContext {
        // This set will store the callback to call when this flow is removed
        private val flowRemovedCallbacks = mutable.Set[Callback0]()
        def addFlowRemovedCallback(cb: Callback0) {
            flowRemovedCallbacks.add(cb)
        }
        // This Set will store the tags by which the flow should be indexed
        // The index can be used to remove flows associated with the given tag
        private val flowTags = mutable.Set[Any]()
        def addFlowTag(tag: Any) {
            flowTags.add(tag)
        }
    }

    trait Device {
        /**
         * Process a packet described by the given match object. Note that the
         * Ethernet packet is the one originally ingressed the virtual network
         * - it does not reflect the changes made by other devices' handling of
         * the packet (whereas the match object does).
         *
         * @param pktMatch The wildcard match that describes the packet's
         * fields at the time it ingresses the device. This match contains the
         * UUID of the ingress port; it can be accessed via getInputPortUUID.
         * The implementation of process should modify the pktMatch to reflect
         * how the device would modify the packet during handling/forwarding.
         * @param packet The original packet that ingressed the virtual network,
         * which may be different from the packet that actually arrives at this
         * device.
         * @param pktContext The context for the simulation of this packet's
         * traversal of the virtual network. Use the context to subscribe
         * for notifications on the removal of any resulting flows, or to tag
         * any resulting flows for indexing.
         * @param ec the Coordinator actor's execution context.
         * @return An instance of Action that reflects what the device would do
         * after handling this packet (e.g. drop it, consume it, forward it).
         */
        def process(pktMatch: WildcardMatch,
                    packet: Ethernet,
                    pktContext: PacketContext,
                    ec: ExecutionContext): Action @cps[Future[_]]
    }

}

/**
 * A Coordinator is an actor that handles the simulation of a single packet
 * moving through the virtual topology (and then dies). A packet begins its
 * journey through the virtual topology in one of these ways:
 * 1) it ingresses an exterior port of a virtual device (in which case the
 * packet arrives via the datapath switch from an entity outside the virtual
 * topology).
 * 2) it egresses an interior port of a virtual device (in which case the
 * packet was generated by that virtual device).
 *
 * In case 1, the match object for the packet was computed by the FlowController
 * and must contain an inPortID. If a wildcard flow is eventually installed in
 * the FlowController, the match will be a subset of the match provided to the
 * simulation Coordinator. Note that in this case the generatedPacketEgressPort
 * argument of the constructor should be null and will be ignored.
 *
 * In case 2, the match object for the packet was computed by the Device that
 * emitted the packet and must not contain an inPortID. If the packet is not
 * dropped, it will eventually result in a packet being emitted from one or
 * more of the datapath ports. However, a flow is never installed as a result
 * of such a simulation. Note that in this case the generatedPacketEgressPort
 * argument of the constructor must not be null.
 *
 * After computing the results of a simulation, the Coordinator always
 * sends messages to the DatapathController to install a flow or send a packet.
 *
 * @param origMatch
 * @param packet
 * @param generatedPacketEgressPort Only used if this packet was generated by
 *                                  a virtual device. It's the ID of the port
 *                                  via which the packet egresses the device.
 */
class Coordinator(val origMatch: WildcardMatch, val packet: Array[Byte],
                  val generatedPacketEgressPort: UUID)
        extends Actor with Coordinator.PacketContext {
    import Coordinator._
    private val log = Logging(context.system, this)
    private val origEthernetPkt = Ethernet.deserialize(packet)
    private var origIngressPort: Port = null
    private var origEgressPort: Port = null
    if (generatedPacketEgressPort == null) {
        if (origMatch.getInputPortUUID == null) {
        log.error("Coordinator cannot simulate a flow that neither " +
            "egressed a virtual device's interior port nor ingressed a " +
            "virtual device's exterior port. Match: {}; Packet: {}",
            origMatch, origEthernetPkt)
        // XXX TODO(pino): kill this actor.
        } else {
            //origIngressPort = virtualTopologyManager().ask(
            //    PortRequest(origMatch.getInputPortUUID, false /* no update */))
        }
    } else {
        if (origMatch.getInputPortUUID != null) {
            log.error("Coordinator cannot simulate a flow that both " +
                "egressed a virtual device's interior port and ingressed a " +
                "virtual device's exterior port. Match: {}; Packet: {}",
                origMatch, origEthernetPkt)
            // XXX TODO(pino): kill this actor.
        } else {
            //origEgressPort = virtualTopologyManager().ask(
            //    PortRequest(origMatch.getInputPortUUID, false /* no update */))
        }
    }

    def isInternallyGenerated: Boolean = { generatedPacketEgressPort != null }

    // Used by the VRNCoordinator to detect loops.
    private val traversedFEs = mutable.Map[UUID, Int]()
    // depth in the VRN simulation
    private val depth: Int = 0

    // Used for connection tracking
    private val connectionTracked = false
    private val forwardFlow = false
    // private val connectionCache
    // Connection-tracking is not done for internally generated packets.
    private val ingressDeviceID: UUID =
        if (isInternallyGenerated) null else origIngressPort.cfg.device_id

    // This starts the simulation of this Coordinator was created to handle.
    simulate(origMatch, packet)

    protected def receive = null

    def datapathController(): ActorRef = {
        // XXX TODO(pino): actorFor("/user/%s" format DatapathController.Name)
        return null
    }

    def virtualTopologyManager(): ActorRef = {
        // XXX TODO(pino): actorFor("/user/%s" format VirtualTopologyActor.Name)
        return null
    }

    def simulate(wFlowMatch: WildcardMatch, packet: Array[Byte]): Unit = {
        while (true) {
            // TODO(jlm): Check for too long loop
            val currentFE = deviceOfPort(wFlowMatch.getInputPortUUID)
            //val result = currentFE.process(pktContext, context.dispatcher)
            /* XXX TODO(pino): result match {
                case ForwardAction(outPortID, outMatch) =>
                    pktContext.mmatch = nextPortMatch.mmatch
                    val peerPort = peerOfPort(nextPortMatch.port)
                    if (peerPort == null)
                        return result
                    pktContext.port = peerPort
                case _ =>
                    // XXX TODO(pino)
            }*/
        }

        val finalMatch = null // TODO(pino)
        if (/*XXX TODO(pino): not*/ isInternallyGenerated) {
            if (true /*null != finalMatch*/) {
                // TODO(pino, jlm): diff matches to build action list
                // XXX
                val actions: List[FlowAction[_]] = null
                // XXX TODO(pino): datapathController() ! SendPacket(packet.getData, actions)
            }
            // Else, do nothing, the packet is dropped.
        } else if (true /*finalMatch == null*/) {
            // XXX TODO(pino): fController ! Consume(null)
        } else {
            // TODO(pino, jlm): compute the WildcardFlow, including actions
            // XXX
            val wildcardFlow: WildcardFlow = null
            datapathController ! AddWildcardFlow(wildcardFlow, null, null, null)
        }

    }

    private def deviceOfPort(port: UUID): Device = {
        null //XXX
    }

    private def peerOfPort(port: UUID): UUID = {
        null //XXX
    }

}
